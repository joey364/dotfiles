'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const path_1 = require("path");
function impor(id, rootDir) {
    if (/^\./.test(id)) {
        id = path_1.join(rootDir, id);
    }
    if (ImportJob.importQueue.indexOf(id) === -1) {
        ImportJob.importQueue.push(id);
    }
    let mod;
    return new Proxy((() => { }), {
        apply: (_, thisArg, argumentsList) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.apply(mod, thisArg, argumentsList);
        },
        construct: (_, argumentsList) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.construct(mod, argumentsList);
        },
        defineProperty: (_, key, attributes) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.defineProperty(mod, key, attributes);
        },
        deleteProperty: (_, key) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.deleteProperty(mod, key);
        },
        get: (_, key, reciver) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.get(mod, key, reciver);
        },
        getPrototypeOf: (_) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.getPrototypeOf(mod);
        },
        has: (_, key) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.has(mod, key);
        },
        isExtensible: (_) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.isExtensible(mod);
        },
        ownKeys: (_) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return mod ? Reflect.ownKeys(mod) : [];
        },
        preventExtensions: (_) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.preventExtensions(mod);
        },
        set: (_, key, value, reciver) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.set(mod, key, value, reciver);
        },
        setPrototypeOf: (_, value) => {
            if (!mod) {
                ImportJob.removeJob(id);
                mod = require(id);
            }
            return Reflect.setPrototypeOf(mod, value);
        }
    });
}
class ImportJob {
    static importJob() {
        return __awaiter(this, void 0, void 0, function* () {
            if (ImportJob.importJobBusy) {
                return;
            }
            if (ImportJob.importQueue.length === 0) {
                return;
            }
            const id = ImportJob.importQueue.shift();
            if (!id) {
                return;
            }
            ImportJob.importJobBusy = true;
            yield Promise.resolve().then(() => require(id));
            ImportJob.importJobBusy = false;
        });
    }
    static removeJob(id) {
        const index = ImportJob.importQueue.indexOf(id);
        if (index === -1) {
            return;
        }
        ImportJob.importQueue.splice(index, 1);
    }
    static start() {
        if (ImportJob.isStarted) {
            return;
        }
        ImportJob.isStarted = true;
        setInterval(ImportJob.importJob, 1000);
    }
}
ImportJob.isStarted = false;
ImportJob.importQueue = [];
ImportJob.importJobBusy = false;
ImportJob.start();
module.exports = (rootDir) => {
    return (id) => {
        return impor(id, rootDir);
    };
};
//# sourceMappingURL=index.js.map